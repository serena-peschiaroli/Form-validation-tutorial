<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Form Validation</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>

  <h1>Form validation</h1>

  <div class="tutorial-section">
    <h2>Cos'è una form validation?</h2>
    <p>Form validation è un processo attivo di controllo per assicurarsi che l'input dell'utente in una web form rispecchi specifici criteri prima dell'invio</p>
    <h3>Perché è importante?</h3>
    <ul>
        <li>Migliora l'esperienza dell'utente provvedendo feedback immediato;</li>
        <li>Assicura l'accuratezza ed integrità dei dati;</li>
        <li>Previene l'invio al server di dati incorretti io dannosi</li>
    </ul>
  </div>

  <div class="tutorial-section">
    <h2>Struttura base di un form</h2>
    <p>La validazione del modulo HTML può essere eseguita utilizzando le funzioni built-in del linguaggio HTML, come l'attributo required o gli attributi di input come pattern, e anche utilizzando JavaScript per la validazione più avanzata.</p>

    <div class="code-example">
      <pre class="highlight">
        <code>
            <xmp> 
            
                <form id="myForm">
                    <label for="nameInput">Name:< /label>
                    <input type="text" id="nameInput" name="name" required>
                    <span id="nameError" class="error">< /span>
                
                    // altri campi di input //
                
                    <button type="submit">Submit< /button>
                </form >
            </xmp>
        </code>
      </pre>
    </div>
     <p>In questo esempio, i campi "username" e "email" sono obbligatori</p>

  </div>
  <div class="tutorial-section">
        <h2>Attributo pattern </h2>
        <p>L'attributo pattern in HTML può essere utilizzato per specificare una regex (espressione regolare) che definisce i criteri di validazione per un campo di input. 
            Questo attributo è utile per garantire che l'utente inserisca dati nel formato desiderato. 
            Qui un esempio di come utilizzare pattern per validare un campo password con almeno 8 caratteri:
        </p>
        <div class="code-example">
            <pre class="highlight">    
                <code>
                    <xmp>
                        <form>
                            <label for="password">Password (almeno 8 caratteri):</label>
                            <input type="password" id="password" name="password" pattern=".{8,}" title="La password deve contenere almeno 8 caratteri">
                            
                            <input type="submit" value="Submit">
                        </form>
                    </xmp>
                        
                </code>
            </pre>
       </div>
    </div>
  </div>
  <div class="tutorial-section">
    <p> pattern=".{8,}" specifica che il campo password deve contenere almeno 8 caratteri.

        title="La password deve contenere almeno 8 caratteri" fornisce un messaggio di suggerimento quando l'utente passa il mouse sopra il campo.
    </p>

    <p>In CSS, puoi anche applicare stili ai campi di input in base al loro stato di validità utilizzando il selettore :valid e :invalid. Ad esempio:</p>
    <div class="code-example">
            <pre class="highlight">
            
                <code class="language-css">
                    input:valid {
                        border: 2px solid green; /* Bordo verde per i campi validi */
                    }
                    
                    input:invalid {
                        border: 2px solid red; /* Bordo rosso per i campi non validi */
                    }
                    
                    
                    
                </code>
            </pre>   
    </div>
   
  </div>
  
  <div class="tutorial-section">
        <h2>maxlength e minlength </h2>
        <p>Questi attributi definiscono la lunghezza massima e minima di un campo di testo.
        </p>
        <div class="code-example">
            <pre class="highlight">
                
                    <code>
                        
                        < input type="text" name="description" maxlength="100" minlength="10">
                       
                        
                    </code>
            </pre>
        </div>
    </div>

    
    <div class="tutorial-section">
        <h2>type="email" e type="url":</h2>
        <p>Questi attributi specificano il tipo di input previsto (indirizzo email o URL) e forniscono una validazione di base.
        </p>
        <div class="code-example">
            <pre class="highlight">
                
                    <code>
                        <xmp>
                            <input type="email" name="userEmail">
                            <input type="url" name="website">
                        </xmp>
                    </code>
            </pre>
        </div>
    </div>
    <div class="tutorial-section">
        <h2>step::</h2>
        <p>L'attributo step definisce gli intervalli validi per i valori di input numerici e di base.
        </p>
        <div class="code-example">
            <pre class="highlight">
                
                    <code>

                        
                        < input type="number" name="quantity" step="5">
                        
                    </code>
            </pre>
        </div>


    </div>
    <div class="tutorial-section">
        <h2>title:</h2>
        <p>L'attributo title fornisce un messaggio di suggerimento quando l'utente passa il mouse sopra il campo.
        </p>
        <div class="code-example">
            <pre class="highlight">
                
                    <code>

                        
                        < input type="text" name="username" title="Inserisci il tuo nome utente">


                        

                        
                        
                    </code>
            </pre>
        </div>
    </div>
    <div class="tutorial-section">
        <h2>autocomplete:</h2>
        <p>L'attributo autocomplete può essere utilizzato per abilitare o disabilitare il completamento automatico dei campi di input.
        </p>
        <div class="code-example">
            <pre class="highlight">
                
                    <code>
                        
                        < input type="text" name="address" autocomplete="on">
                        
                    </code>
            </pre>
        </div>


    </div>
    <div class="tutorial-section">
        <h2>Convalida dei moduli utilizzando JavaScript</h2>
        <h4>di Giacomo Franchi</h4>
        <p>
            È necessario utilizzare JavaScript per assumere il controllo sull'aspetto dei messaggi di errore nativi come ad esempio "validity".
        </p>
        <p>
            validity: Restituisce un ValidityState oggetto che contiene diverse proprietà che descrivono lo stato di validità dell'elemento.

            <li>
                valid: 
                Restituisce true se l'elemento soddisfa tutti i suoi vincoli di validazione, ed è quindi considerato valido, o false se fallisce qualsiasi vincolo
            </li>
            <li>
                tooLong: 
                Restituisce truese il valore è più lungo della lunghezza massima specificata dall'attributo maxlengtho falsese è più corto o uguale al massimo.// tooShort:
            </li>
            <li>
                rangeOverflow: // rangeUnderflow:
                 Restituisce true se il valore è inferiore al minimo specificato dall'attributo mino falsese è maggiore o uguale al minimo.
            </li>
            <li>
                typeMismatch: 
                Restituisce truese il valore non è nella sintassi richiesta (quando type è email o url) o false se la sintassi è corretta.

            </li>
        </p>
        <div class="code-example">
            <pre class="highlight">
                
                    <code>
                        esempio:
                        HTML
                        < form novalidate> "novalidate" per disattivare la convalida automatica del browser, non disabilita  pseudo-classi CSS come :valid.
                        < p>
                            < label for="mail">
                            < span>Please enter an email address:</ span>
                            < input type="email" id="mail" name="mail" required minlength="8" />
                            < span class="error" aria-live="polite"></ span>
                            </ label>
                        < /p>
                        < button>Submit</ button>
                        </ form>
                        
                    </code>
            </pre>  
        
        </div>
        <p>
            Un punto chiave qui è che l'impostazione dell'attributo novalidate sul modulo è ciò che impedisce al modulo di mostrare i propri fumetti di errore e ci consente invece di visualizzare i messaggi di errore personalizzati nel DOM in un modo a nostra scelta.

        </p>
        <div class="code-example">
            
                <pre class="highlight">
                    
                    <code>
                                                JS
                        // iniziamo dichiarando le variabili
                        const form = document.querySelector("form");
                        const email = document.getElementById("mail");
                        const emailError = document.querySelector("#mail + span.error");
                        form.addEventListener("submit", (event) => {
                        // Controlliamo se l'email soddisfa tutti i requisiti dati in HTML
                        if (!email.validity.valid) {
                            // Se non li rispetta richiamiamo la funzione showError
                            showError();
                            // Evitiamo che i campi di input si svuotino
                            event.preventDefault();
                        }
                        });
                        // Controlla che l'imput non sia vuoto, che venga rispettato il type dell'input e la lunghezza minima
                        function showError() {
                        if (email.validity.valueMissing) {
                            // Se il campo è vuoto mostra questo messaggio di errore
                            emailError.textContent = "You need to enter an email address.";
                        } else if (email.validity.typeMismatch) {
                            // Se non viene riconosciuto un indirizzo email
                            emailError.textContent = "Entered value needs to be an email address.";
                        } else if (email.validity.tooShort) {
                            // se l'imput è troppo corto
                            emailError.textContent = `Email should be at least ${email.minLength} characters; you entered ${email.value.length}.`;
                        }
                        // aggiungere feedback visivo con css
                        emailError.className = "error active";
                        }
                        
                    </code>
             </pre>

        </div>
    </div>
  
  <div class="tutorial-section">
        <h2>Validation con Javascript: Validazione basata su condizioni:</h2>
        <p>
            Si possono utilizzare istruzioni condizionali per verificare se i campi del form soddisfano determinate condizioni. Ad esempio, si può controllare se un campo è vuoto o se un numero è maggiore di una certa quantità.

        </p>

        <div class="code-example">
            <pre class="highlight">
                <code>
                    document.getElementById('registrazioneForm').addEventListener('submit', function(event) {
                        let valido = true;
                    
                        // Validazione per ogni campo di input
                        // ...
                    
                        // Impedisci l'invio del form se la validazione fallisce
                        if (!valido) {
                        event.preventDefault();
                        }
                    });
                    
                </code>
            </pre>
        </div>
  </div>

  <div class="tutorial-section">
    <h2>Espressioni regolari (Regex):</h2>
    <p>Si possono utilizzare espressioni regolari per definire modelli specifici che devono essere rispettati. Ad esempio, per la validazione di un'email, di un numero di telefono o di un indirizzo:</p>

    <div class="code-example">
      <pre>
        <code>
            function isValidEmail(email) {
                const regexEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                return regexEmail.test(email);
            }
            
            // Uso
            const emailInput = document.getElementById('email');
            if (!isValidEmail(emailInput.value)) {
                alert('Inserisci un indirizzo email valido');
                valido = false;
            }
            
        </code>
      </pre>
    </div>
    <p>Oppure:</p>
    <div class="code-example">
        <pre>
            <code>
                const regexTelefono = /^\+(?:[0-9]●?){6,14}[0-9]$/;

                const regexCodicePostaleUSA = /^\d{5}(?:[-\s]\d{4})?$/;

                const regexData = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;

            </code>
        </pre>
    </div>
        <div class="code-example">
            <pre>
                <code>
                    const telefonoInput = document.getElementById('telefono');
                    const codicePostaleInput = document.getElementById('codicePostale');
                    const dataInput = document.getElementById('data');

                    // Funzione di validazione per il numero di telefono
                    function isValidTelefono(telefono) {
                        const regexTelefono = /^\+(?:[0-9]●?){6,14}[0-9]$/;
                        return regexTelefono.test(telefono);
                    }

                    // Funzione di validazione per il codice postale
                    function isValidCodicePostale(codicePostale) {
                        const regexCodicePostaleUSA = /^\d{5}(?:[-\s]\d{4})?$/;
                        return regexCodicePostaleUSA.test(codicePostale);
                    }

                    // Funzione di validazione per la data
                    function isValidData(data) {
                        const regexData = /^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
                        return regexData.test(data);
                    }

                    // Aggiungi eventi di ascolto e chiamate alle funzioni di validazione
                    telefonoInput.addEventListener('blur', function () {
                        if (!isValidTelefono(telefonoInput.value)) {
                            // Mostra messaggio di errore per il numero di telefono non valido
                            // ...
                        }
                    });

                    codicePostaleInput.addEventListener('blur', function () {
                        if (!isValidCodicePostale(codicePostaleInput.value)) {
                            // Mostra messaggio di errore per il codice postale non valido
                            // ...
                        }
                    });

                    dataInput.addEventListener('blur', function () {
                        if (!isValidData(dataInput.value)) {
                            // Mostra messaggio di errore per la data non valida
                            // ...
                        }
                    });



                </code>
            </pre>
        </div>
        
  </div>

  <div class="tutorial-section">
        <h2>Constraint API:</h2>
        <p>
            Si possono utilizzare la Constraint API, che fornisce un set di metodi e proprietà per accedere e modificare i vincoli di validazione di un elemento. Ad esempio:
        </p>

        <div class="code-example">
            <pre>
                <code>
                    const ageInput = document.getElementById('age');
                    const ageError = document.getElementById('ageError');

                    ageInput.addEventListener('input', function() {
                        if (ageInput.validity.rangeUnderflow) {
                        ageError.textContent = 'L\'età deve essere maggiore di  18';
                        } else {
                            ageError.textContent = '';
                        }
                    });

                </code>
            </pre>
        </div>
        <p>
            In questo esempio, la Constraint API è utilizzata per controllare se l'età è maggiore di 18.

            Questi sono solo esempi di base. La validazione del modulo può essere personalizzata ulteriormente in base alle esigenze specifiche del progetto da realizzare. 
        </p>
    </div>
       

  <div class="tutorial-section">
    <h2>Utilizzo di checkValidity</h2>
        <p>
            JavaScript può essere utilizzato per la validazione più avanzata. Ad esempio, la funzione checkValidity controlla se     un elemento soddisfa tutti i vincoli di validità.
            checkValidity() è un metodo della Constraint Validation API in JavaScript che può essere utilizzato per verificare se un elemento del form soddisfa tutti i vincoli di validità imposti su di esso. Questi vincoli possono includere attributi HTML come required, pattern, min, max, ecc.


        </p>

    <div class="code-example">
      <pre>
        <code>
            document.getElementById('myForm').addEventListener('submit', function(event) {
                const customField = document.getElementById('customField');
            
                if (!customField.checkValidity()) {
                  // Se la validazione fallisce, gestisci l'errore qui
                  alert("Il campo personalizzato deve iniziare con 'A'");
                  event.preventDefault(); // Impedisci l'invio del modulo
                }
              });
        </code>
      </pre>
    </div>
  </div>
  <p>
        In questo esempio, stiamo ascoltando l'evento di invio del form. Quando il form viene inviato, controlliamo la validità del campo personalizzato utilizzando checkValidity(). Se la validazione fallisce, mostriamo un messaggio di avviso e impediamo l'invio del modulo con event.preventDefault().

        Questo metodo è utile quando desideri eseguire una validazione più avanzata rispetto agli attributi HTML standard o quando vuoi personalizzare il comportamento della validazione in base alle tue esigenze specifiche.  
    </p>

  <div class="tutorial-section">
    <h2>Visualizzazione dei Messaggi di Errore</h2>
    <p>
        La visualizzazione dei messaggi di errore è una componente cruciale nella validazione dei form con JavaScript.
    </p>
    <p>
        Questo processo fornisce feedback istantaneo agli utenti riguardo agli errori nei dati inseriti, migliorando così l'esperienza complessiva.
    </p>
    <p>
        Nel codice JavaScript associato a ciascun campo del form, vengono implementate condizioni che attivano la visualizzazione di messaggi di errore specifici quando si verificano determinati scenari, come campi obbligatori vuoti.

    </p>
    <p>
        Questa pratica non solo aiuta gli utenti a correggere gli errori immediatamente, ma contribuisce anche a mantenere l'integrità e l'accuratezza dei dati nel sistema.

    </p>
    <p>
        La personalizzazione dei messaggi di errore e l'integrazione con altri metodi di validazione consentono di adattare la visualizzazione degli errori alle esigenze specifiche del progetto.

    </p>

    <div class="code-example">
      <pre>
        <code>
            // Esempio: Visualizzazione di un messaggio di errore per il campo del nome
            let valido = true;

            const nomeErrore = document.getElementById('nomeErrore');
            const nomeInput = document.getElementById('nomeInput');

            nomeInput.addEventListener('blur', function() {
             if (nomeInput.value === '') {
            nomeErrore.textContent = 'Il nome è obbligatorio';
            valido = false;
             } else {
            nomeErrore.textContent = '';
            }
            
        </code>
      </pre>
    </div>
  </div>
  
    <div class="tutorial-section">
        <h2>L'importanza di una buona pratica di validazione dei form: il Cross Site Scripting (XSS)</h2>
        <p>
            Il cross site scripting è una falla nella sicurezza che avviene quando vengono iniettati script maligni in un'appplicazione web, poi eseguiti dal browser di user inconsapevoli
        </p>
        <p>
            il termine "cross-site" indica che l'attacco coinvolge script da un sito web eseguiti nel contesto di un altro sito web.
        </p>
        <p>
            Ci sono tre principali tipi di XSS:
            <ol> 
                <li>
                    <h3>Stored (persistent) XSS: </h3>
                    script maligni che sono memorizzati sul server di destinazione, spesso in un database. Quando un utente richiede la pagina interessata, lo script viene servito insieme al contenuto legittimo ed il browser dell'utente lo esegue.
                </li>
                <li>
                    <h3>Reflected (Non-Persistent) XSS:</h3>
                    lo script maligno è incorporato in un URL ed il server lo riflette all'utente n ella risposta. Il browser dell'utete esegue quindi lo script: 
                    <strong> Questo tipo è solutamente il risultato dell'inserimento di script in campi di input o url</strong>
                </li>
                <li>
                    <h3>Dom-Based XXS:</h3>
                    L'attacco avviene nel Document Object Model (DOM), dove lo script lato client manipola il DOM in base all'input dell'utente. Se la manipolazione comporta l'esecuzione di uno script maligno, diventa un attacco XSS basato su DOM.
                </li>
            </ol>
        </p>
        <h2> Come Funziona l'XSS:</h2>
        <p>
            <ol>
                <li>
                    <h3>Iniezione:</h3>
                    Un hacker inietta codice maligno (solitamente JavaScript) in campi di input, URL o altre aree controllate dall'utente.
                </li>
                <li>
                    <h3>Esecuzione</h3>
                    Il codice iniettato viene quindi servito ad altri utenti o eseguito quando la vittima accede a una pagina specifica o interagisce con un componente vulnerabile.
                </li>
                <li>
                    <h3> Impatto: </h3>
                    Lo script maligno può rubare dati dell'utente, cookie di sessione, credenziali di accesso o compiere azioni a nome dell'utente senza il loro consenso.
                </li>
            </ol>

        </p>
        <h2>Prevenzione dell'XSS:</h2>
        <p>
            <ol>
                <li>
                    <h3>Validazione dell'Input:</h3>
                    Convalidare e sanificare l'input dell'utente sia lato client che lato server.
                </li>
                <li>
                    <h3>Codifica dell'Output:</h3>
                    Codificare l'input dell'utente prima di renderizzarlo sulla pagina web per neutralizzare eventuali codici maligni potenziali.
                </li>
                <li>
                    <h3>Content Security Policy (CSP):</h3>
                    Implementare una CSP robusta per controllare quali script possono essere eseguiti su una pagina.
                </li>
                <li>
                    <h3>Cookies HttpOnly:</h3>
                    Utilizzare cookie HttpOnly per impedire che siano accessibili da script lato client.
                </li>
                <li>
                    <h3>Auditing Regolare della Sicurezza:</h3>

                    Effettuare regolarmente audit e scansioni dell'applicazione per individuare vulnerabilità, inclusa l'XSS.
                    Comprendere e mitigare l'XSS è cruciale per <strong> mantenere la sicurezza</strong> delle applicazioni web  <strong>  proteggere gli utenti</strong>da potenziali attacchi maligni.
                </li>
            </ol>
            

        </p>
        <h2>Esempio di injection XSS su una form:</h2>
        <div class="code-example">
            <pre class="highlight">
                <div class="code-example">
                    <pre class="highlight">
                        <code>
                            &lt;!-- Form HTML Vulnerabile --&gt;
                            &lt;form action="/submit-comment" method="post"&gt;
                                &lt;label for="comment"&gt;Lascia un commento:&lt;/label&gt;
                                &lt;textarea id="comment" name="comment"&gt;&lt;/textarea&gt;
                                &lt;button type="submit"&gt;Invia&lt;/button&gt;
                            &lt;/form&gt;
                
                            &lt;!-- Visualizzazione dei commenti senza una valida validazione --&gt;
                            &lt;div id="comments"&gt;
                                &lt;!-- Visualizzazione dei commenti degli utenti senza una valida validazione --&gt;
                            &lt;/div&gt;
                        </code>
                    </pre>
                </div>
                
            </pre>
        </div>
        <h2>Javascript lato server </h2>
        <div class="code-example">
            <pre class="highlight">
                <div class="code-example">
                    <pre class="highlight">
                        <code>
                            // Esempio con Node.js ed Express
                                const express = require('express');
                                const bodyParser = require('body-parser');
                                const app = express();

                                app.use(bodyParser.urlencoded({ extended: true }));

                                // Gestione della sottomissione del form
                                app.post('/submit-comment', (req, res) => {
                                    const userComment = req.body.comment;

                                    // Memorizza il commento nel database (esempio semplificato)
                                    // In uno scenario del mondo reale, qui si effettuerebbe una valida validazione e sanitizzazione.

                                    // Per illustrazione, assumiamo che il commento sia memorizzato in una variabile.
                                    const storedComment = userComment;

                                    // Invia una risposta (in uno scenario reale, potresti reindirizzare o renderizzare una nuova pagina)
                                    res.send('Commento inviato con successo!');
                                });

                                // Servizio della pagina del form
                                app.get('/', (req, res) => {
                                    // In uno scenario del mondo reale, avresti un valido motore di template HTML
                                    res.sendFile(__dirname + '/form.html');
                                });

                                app.listen(3000, () => {
                                    console.log('Il server è in esecuzione sulla porta 3000');
                                });

                        </code>
                    </pre>
                </div>
                
            </pre>
        </div>
        <p>
            Nel contesto specifico di questo codice, il rischio deriva dall'invio del commento dell'utente direttamente nella risposta senza alcuna validazione o sanitizzazione. Se un utente malintenzionato inserisse un commento contenente codice JavaScript dannoso, questo sarebbe eseguito quando la risposta viene visualizzata nel browser di altri utenti.
        </p>
        <p>
            Ora, un hacker potrebbe inviare il seguente payload nel campo del commento:
        </p>
        <div class="code-example">
            <pre>
                <code>
                    &lt;script&gt;
                        alert("Attacco XSS!");
                    &lt;/script&gt;
                </code>
            </pre>
        </div>
        
        <p>
            Se questo payload viene inviato e l'applicazione non effettua una valida validazione e sanificazione dell'input, lo script iniettato verrà memorizzato nel database e quindi visualizzato sulla pagina web quando i commenti vengono recuperati e renderizzati.
        </p>
        <p>
            In uno scenario del mondo reale, gli hacker potrebbero utilizzare payload più sofisticati per rubare i cookie di sessione, reindirizzare gli utenti a siti web maligni o eseguire altre attività dannose. Una corretta validazione dell'input, la codifica dell'output e la sanificazione sono cruciali per prevenire vulnerabilità XSS.
        </p>
    </div>
    <div class="tutorial-section">
        <h2>Conclusioni:</h2>
        <p>
            Oggi abbiamo esplorato la potenza di HTML5 e JavaScript nella validazione dei form. Sfruttando attributi HTML5 come required e pattern, garantiamo un feedback immediato all'utente. JavaScript, con la sua Constraint API, ci consente di prendere il controllo del processo di validazione, offrendo un'esperienza più dinamica e personalizzata.

        </p>
        <p>
            Abbiamo visto come la gestione degli errori, esemplificata da messaggi chiari legati a campi specifici del form, non solo guidi gli utenti ma migliora anche l'usabilità complessiva. Inoltre, i nostri sforzi di validazione contribuiscono alla sicurezza dell'applicazione, prevenendo vulnerabilità comuni come gli attacchi di cross-site scripting (XSS).
        </p>
        <p>
            In conclusione, una strategia robusta di validazione dei form va oltre il soddisfacimento dei requisiti tecnici; è un elemento chiave nel plasmare un'esperienza utente positiva, garantendo l'integrità dei dati e rafforzando la sicurezza delle nostre applicazioni web. 

            Grazie per il vostro tempo!
        </p>

    </div>
    <footer>
        <p>Make with ❤ by Team 8</p>
    </footer>
</body>
</html>
